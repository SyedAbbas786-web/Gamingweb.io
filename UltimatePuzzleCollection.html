<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate Puzzle Collection | SyedAbbas Games</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
    <style>
        /* Reset & Base */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: manipulation;
        }

        :root {
            /* Light Theme */
            --light-primary: #4361ee;
            --light-secondary: #3a0ca3;
            --light-accent: #f72585;
            --light-success: #4cc9f0;
            --light-warning: #f8961e;
            --light-bg: #f8f9fa;
            --light-card: #ffffff;
            --light-text: #212529;
            --light-text-secondary: #6c757d;
            --light-border: #dee2e6;
            --light-shadow: 0 8px 30px rgba(0, 0, 0, 0.08);
            
            /* Dark Theme */
            --dark-primary: #4361ee;
            --dark-secondary: #3a0ca3;
            --dark-accent: #f72585;
            --dark-success: #4cc9f0;
            --dark-warning: #f8961e;
            --dark-bg: #121212;
            --dark-card: #1e1e1e;
            --dark-text: #ffffff;
            --dark-text-secondary: #adb5bd;
            --dark-border: #2d2d2d;
            --dark-shadow: 0 8px 30px rgba(0, 0, 0, 0.3);
        }

        body {
            font-family: 'Poppins', sans-serif;
            background-color: var(--bg);
            color: var(--text);
            min-height: 100vh;
            padding: 20px;
            transition: all 0.3s ease;
            overflow-x: hidden;
        }

        body.light-theme {
            --primary: var(--light-primary);
            --secondary: var(--light-secondary);
            --accent: var(--light-accent);
            --success: var(--light-success);
            --warning: var(--light-warning);
            --bg: var(--light-bg);
            --card: var(--light-card);
            --text: var(--light-text);
            --text-secondary: var(--light-text-secondary);
            --border: var(--light-border);
            --shadow: var(--light-shadow);
        }

        body.dark-theme {
            --primary: var(--dark-primary);
            --secondary: var(--dark-secondary);
            --accent: var(--dark-accent);
            --success: var(--dark-success);
            --warning: var(--dark-warning);
            --bg: var(--dark-bg);
            --card: var(--dark-card);
            --text: var(--dark-text);
            --text-secondary: var(--dark-text-secondary);
            --border: var(--dark-border);
            --shadow: var(--dark-shadow);
        }

        .container {
            width: 100%;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Header */
        .header {
            text-align: center;
            margin-bottom: 30px;
            width: 100%;
            position: relative;
        }

        .title {
            font-size: clamp(2rem, 5vw, 3.5rem);
            font-weight: 800;
            background: linear-gradient(90deg, var(--primary), var(--accent));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            margin-bottom: 10px;
            letter-spacing: -0.5px;
        }

        .subtitle {
            font-size: clamp(1rem, 2vw, 1.2rem);
            color: var(--text-secondary);
            max-width: 800px;
            margin: 0 auto 20px;
            line-height: 1.5;
        }

        /* Theme Toggle */
        .theme-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
        }

        .theme-btn {
            background: var(--card);
            border: 2px solid var(--border);
            border-radius: 50px;
            padding: 10px 20px;
            font-size: 1rem;
            font-weight: 600;
            color: var(--text);
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 10px;
            box-shadow: var(--shadow);
        }

        .theme-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
        }

        /* Main Container */
        .main-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            min-height: 70vh;
        }

        /* Menu Section */
        .menu-section {
            background: var(--card);
            border-radius: 20px;
            padding: 30px;
            box-shadow: var(--shadow);
            border: 1px solid var(--border);
            width: 100%;
            text-align: center;
            animation: fadeIn 0.5s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .menu-title {
            font-size: 1.8rem;
            font-weight: 700;
            color: var(--text);
            margin-bottom: 25px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
        }

        .menu-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .menu-card {
            background: var(--bg);
            border-radius: 15px;
            padding: 25px;
            border: 2px solid var(--border);
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            min-height: 200px;
            justify-content: center;
            position: relative;
        }

        .menu-card:hover {
            transform: translateY(-5px);
            border-color: var(--primary);
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.1);
        }

        .menu-card i {
            font-size: 3rem;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }

        .menu-card h3 {
            font-size: 1.4rem;
            font-weight: 600;
            color: var(--text);
            text-align: center;
        }

        .menu-card p {
            font-size: 0.9rem;
            color: var(--text-secondary);
            text-align: center;
            line-height: 1.4;
        }

        .difficulty-badge {
            display: inline-block;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 600;
            margin-top: 5px;
        }

        .easy { background: rgba(76, 201, 240, 0.2); color: var(--success); }
        .medium { background: rgba(248, 150, 30, 0.2); color: var(--warning); }
        .hard { background: rgba(247, 37, 133, 0.2); color: var(--accent); }

        /* Game Container */
        .game-container {
            background: var(--card);
            border-radius: 20px;
            padding: 25px;
            box-shadow: var(--shadow);
            border: 1px solid var(--border);
            width: 100%;
            display: none;
            animation: fadeIn 0.5s ease;
        }

        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            padding-bottom: 20px;
            border-bottom: 2px solid var(--border);
            flex-wrap: wrap;
            gap: 15px;
        }

        .game-title {
            font-size: 1.6rem;
            font-weight: 700;
            color: var(--text);
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .game-stats {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }

        .stat-box {
            background: var(--bg);
            padding: 10px 15px;
            border-radius: 10px;
            border: 2px solid var(--border);
            text-align: center;
            min-width: 100px;
        }

        .stat-label {
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.4rem;
            font-weight: 700;
            color: var(--text);
        }

        /* Game Content */
        .game-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 25px;
        }

        .game-board-container {
            width: 100%;
            max-width: min(600px, 90vw);
            margin: 0 auto;
            overflow: hidden;
            border-radius: 15px;
            background: var(--bg);
            padding: 15px;
            border: 2px solid var(--border);
        }

        .game-board {
            display: grid;
            gap: 8px;
            margin: 0 auto;
            width: 100%;
            aspect-ratio: 1/1;
        }

        .tile {
            background: var(--card);
            border: 2px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            user-select: none;
            font-size: 1.2rem;
            -webkit-tap-highlight-color: transparent;
        }

        .tile:hover:not(.empty):not(.matched):not(.locked) {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        .empty {
            background: transparent;
            border-color: transparent;
            cursor: default;
        }

        .locked {
            cursor: default;
            opacity: 0.7;
        }

        .matched {
            background: rgba(76, 201, 240, 0.2);
            border-color: var(--success);
        }

        .selected {
            background: rgba(67, 97, 238, 0.2);
            border-color: var(--primary);
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .correct {
            background: rgba(76, 201, 240, 0.2);
            border-color: var(--success);
        }

        .wrong {
            background: rgba(247, 37, 133, 0.2);
            border-color: var(--accent);
            animation: shake 0.5s;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        /* Game Info Panel */
        .game-info-panel {
            background: var(--bg);
            border-radius: 15px;
            padding: 20px;
            border: 2px solid var(--border);
            width: 100%;
            max-width: 600px;
            margin-top: 10px;
        }

        .info-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .difficulty-selector {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .difficulty-btn {
            padding: 8px 16px;
            background: var(--card);
            border: 2px solid var(--border);
            border-radius: 8px;
            color: var(--text);
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .difficulty-btn:hover {
            border-color: var(--primary);
        }

        .difficulty-btn.active {
            border-color: var(--primary);
            background: rgba(67, 97, 238, 0.1);
        }

        .game-instructions {
            background: var(--card);
            padding: 15px;
            border-radius: 10px;
            margin-top: 15px;
            border: 1px solid var(--border);
        }

        .game-instructions h4 {
            color: var(--text);
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .game-instructions p {
            color: var(--text-secondary);
            line-height: 1.5;
            font-size: 0.95rem;
        }

        /* Word List for Word Search */
        .word-list-container {
            background: var(--card);
            padding: 15px;
            border-radius: 10px;
            margin-top: 15px;
            border: 1px solid var(--border);
        }

        .word-list {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
        }

        .word-item {
            padding: 6px 12px;
            background: var(--bg);
            border: 2px solid var(--border);
            border-radius: 20px;
            font-weight: 600;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }

        .word-item.found {
            background: rgba(76, 201, 240, 0.2);
            border-color: var(--success);
            color: var(--success);
            text-decoration: line-through;
            transform: scale(0.95);
        }

        /* Mobile Controls */
        .mobile-controls {
            display: none;
            gap: 10px;
            margin-top: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .mobile-btn {
            padding: 12px 20px;
            background: var(--card);
            border: 2px solid var(--border);
            border-radius: 10px;
            font-size: 1.5rem;
            cursor: pointer;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            min-width: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Controls */
        .controls {
            display: flex;
            justify-content: center;
            gap: 12px;
            margin-top: 25px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 10px;
            font-family: 'Poppins', sans-serif;
            font-weight: 600;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 10px;
            color: white;
            min-height: 48px;
            -webkit-tap-highlight-color: transparent;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
        }

        .btn-secondary {
            background: var(--text-secondary);
        }

        .btn-success {
            background: linear-gradient(135deg, var(--success), #2a9d8f);
        }

        .btn-danger {
            background: linear-gradient(135deg, var(--accent), #b5179e);
        }

        .btn-warning {
            background: linear-gradient(135deg, var(--warning), #d68c0e);
        }

        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
        }

        .btn:active {
            transform: translateY(-1px);
        }

        /* Overlay */
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(5px);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            animation: fadeIn 0.3s ease;
            padding: 20px;
        }

        .overlay-content {
            background: var(--card);
            border-radius: 20px;
            padding: 30px;
            max-width: 500px;
            width: 100%;
            text-align: center;
            animation: slideUp 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            border: 1px solid var(--border);
            box-shadow: var(--shadow);
        }

        @keyframes slideUp {
            from { transform: translateY(50px) scale(0.9); opacity: 0; }
            to { transform: translateY(0) scale(1); opacity: 1; }
        }

        .overlay h2 {
            font-size: clamp(1.8rem, 4vw, 2.5rem);
            margin-bottom: 20px;
            background: linear-gradient(90deg, var(--primary), var(--accent));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }

        .overlay p {
            font-size: clamp(1rem, 2vw, 1.2rem);
            margin-bottom: 30px;
            color: var(--text);
            line-height: 1.5;
        }

        /* Back to Games Button */
        .back-to-games {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1000;
        }

        .back-btn {
            background: var(--card);
            border: 2px solid var(--border);
            border-radius: 50px;
            padding: 10px 20px;
            font-size: 1rem;
            font-weight: 600;
            color: var(--text);
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 10px;
            box-shadow: var(--shadow);
        }

        .back-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .menu-section,
            .game-container {
                padding: 20px;
            }
            
            .menu-grid {
                grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
                gap: 15px;
            }
            
            .game-header {
                flex-direction: column;
                align-items: stretch;
                text-align: center;
            }
            
            .game-stats {
                justify-content: center;
            }
            
            .stat-box {
                min-width: 80px;
                padding: 8px 12px;
            }
            
            .stat-value {
                font-size: 1.2rem;
            }
            
            .controls {
                flex-direction: column;
                width: 100%;
            }
            
            .btn {
                width: 100%;
                justify-content: center;
            }
            
            .mobile-controls {
                display: flex;
            }
            
            .game-board-container {
                padding: 10px;
            }
            
            .tile {
                font-size: 1rem;
            }
        }

        @media (max-width: 480px) {
            .menu-grid {
                grid-template-columns: 1fr;
            }
            
            .menu-card {
                min-height: 160px;
                padding: 20px;
            }
            
            .menu-card i {
                font-size: 2.5rem;
            }
            
            .menu-card h3 {
                font-size: 1.2rem;
            }
            
            .title {
                font-size: 2rem;
            }
            
            .game-title {
                font-size: 1.4rem;
            }
            
            .theme-btn,
            .back-btn {
                padding: 8px 16px;
                font-size: 0.9rem;
            }
        }

        /* Specific Game Styles */
        .sudoku-cell {
            font-size: clamp(1rem, 2vw, 1.5rem);
        }

        .sudoku-cell:nth-child(3n) {
            border-right: 3px solid var(--border);
        }

        .sudoku-cell:nth-child(n+19):nth-child(-n+27),
        .sudoku-cell:nth-child(n+46):nth-child(-n+54) {
            border-bottom: 3px solid var(--border);
        }

        .memory-card {
            perspective: 1000px;
        }

        .memory-card-inner {
            position: relative;
            width: 100%;
            height: 100%;
            transform-style: preserve-3d;
            transition: transform 0.6s;
        }

        .memory-card.flipped .memory-card-inner {
            transform: rotateY(180deg);
        }

        .memory-card-front,
        .memory-card-back {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(1.5rem, 3vw, 2rem);
        }

        .memory-card-front {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
        }

        .memory-card-back {
            background: var(--card);
            color: var(--text);
            transform: rotateY(180deg);
        }

        /* Loading Spinner */
        .loading-spinner {
            display: none;
            justify-content: center;
            align-items: center;
            height: 200px;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid var(--border);
            border-top: 5px solid var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Toast Notifications */
        .toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: var(--card);
            color: var(--text);
            padding: 15px 20px;
            border-radius: 10px;
            border: 2px solid var(--success);
            box-shadow: var(--shadow);
            transform: translateY(100px);
            opacity: 0;
            transition: all 0.3s ease;
            z-index: 3000;
            max-width: 300px;
        }

        .toast.show {
            transform: translateY(0);
            opacity: 1;
        }

        /* Game Complete Animation */
        @keyframes confetti {
            0% { transform: translateY(-100px) rotate(0deg); opacity: 1; }
            100% { transform: translateY(100vh) rotate(360deg); opacity: 0; }
        }

        .confetti {
            position: fixed;
            width: 10px;
            height: 10px;
            background: var(--primary);
            opacity: 0;
            z-index: 1000;
        }
    </style>
</head>
<body class="dark-theme">
    <!-- Back to Games Button -->
    <div class="back-to-games">
        <button class="back-btn" id="backToGames">
            <i class="fas fa-arrow-left"></i> Back to Games
        </button>
    </div>

    <!-- Theme Toggle -->
    <div class="theme-toggle">
        <button class="theme-btn" id="themeToggle">
            <i class="fas fa-moon"></i> Dark Mode
        </button>
    </div>

    <!-- Main Container -->
    <div class="container">
        <!-- Header -->
        <header class="header" id="mainHeader">
            <h1 class="title">Ultimate Puzzle Collection</h1>
            <p class="subtitle">12 addictive puzzle games in one beautiful package. Challenge your brain and have fun!</p>
        </header>

        <!-- Main Container -->
        <div class="main-container">
            <!-- Main Menu -->
            <section class="menu-section" id="mainMenu">
                <div class="menu-title">
                    <i class="fas fa-gamepad"></i> Select a Puzzle Game
                </div>
                <div class="menu-grid">
                    <!-- Fully Working Games -->
                    <div class="menu-card" data-game="memory">
                        <i class="fas fa-brain"></i>
                        <h3>Memory Match</h3>
                        <p>Find matching pairs of cards. Test your memory!</p>
                        <span class="difficulty-badge easy">Easy-Medium-Hard</span>
                    </div>

                    <div class="menu-card" data-game="sliding">
                        <i class="fas fa-th"></i>
                        <h3>Sliding Puzzle</h3>
                        <p>Arrange tiles in order. Classic 15-puzzle!</p>
                        <span class="difficulty-badge medium">3 Sizes</span>
                    </div>

                    <div class="menu-card" data-game="sudoku">
                        <i class="fas fa-table"></i>
                        <h3>Sudoku</h3>
                        <p>Fill the grid with numbers 1-9. Logic puzzle!</p>
                        <span class="difficulty-badge hard">Easy-Hard-Expert</span>
                    </div>

                    <div class="menu-card" data-game="wordsearch">
                        <i class="fas fa-search"></i>
                        <h3>Word Search</h3>
                        <p>Find hidden words in the grid. Vocabulary fun!</p>
                        <span class="difficulty-badge medium">3 Levels</span>
                    </div>

                    <div class="menu-card" data-game="nonogram">
                        <i class="fas fa-drafting-compass"></i>
                        <h3>Nonogram</h3>
                        <p>Picture logic puzzle. Solve the image!</p>
                        <span class="difficulty-badge hard">3 Sizes</span>
                    </div>

                    <div class="menu-card" data-game="match3">
                        <i class="fas fa-gem"></i>
                        <h3>Match-3 Puzzle</h3>
                        <p>Swap gems to make matches. Colorful fun!</p>
                        <span class="difficulty-badge easy">3 Modes</span>
                    </div>

                    <!-- Coming Soon Games -->
                    <div class="menu-card" data-game="comingsoon1">
                        <i class="fas fa-puzzle-piece"></i>
                        <h3>Jigsaw Puzzle</h3>
                        <p>Drag pieces to complete image. Coming soon!</p>
                        <span class="difficulty-badge medium">Soon</span>
                    </div>

                    <div class="menu-card" data-game="comingsoon2">
                        <i class="fas fa-shapes"></i>
                        <h3>Tangram</h3>
                        <p>Arrange shapes to match silhouette. Soon!</p>
                        <span class="difficulty-badge medium">Soon</span>
                    </div>

                    <div class="menu-card" data-game="comingsoon3">
                        <i class="fas fa-project-diagram"></i>
                        <h3>Flow Free</h3>
                        <p>Connect matching colors. Coming soon!</p>
                        <span class="difficulty-badge medium">Soon</span>
                    </div>

                    <div class="menu-card" data-game="comingsoon4">
                        <i class="fas fa-sort-numeric-up"></i>
                        <h3>2048</h3>
                        <p>Slide and combine tiles. Coming soon!</p>
                        <span class="difficulty-badge hard">Soon</span>
                    </div>

                    <div class="menu-card" data-game="comingsoon5">
                        <i class="fas fa-font"></i>
                        <h3>Crossword</h3>
                        <p>Fill words based on clues. Coming soon!</p>
                        <span class="difficulty-badge medium">Soon</span>
                    </div>

                    <div class="menu-card" data-game="comingsoon6">
                        <i class="fas fa-lightbulb"></i>
                        <h3>Lights Out</h3>
                        <p>Turn off all lights. Coming soon!</p>
                        <span class="difficulty-badge medium">Soon</span>
                    </div>
                </div>

                <div class="controls">
                    <button class="btn btn-secondary" id="howToPlay">
                        <i class="fas fa-question-circle"></i> How to Play
                    </button>
                    <button class="btn btn-warning" id="viewStats">
                        <i class="fas fa-chart-bar"></i> View Stats
                    </button>
                </div>
            </section>

            <!-- Game Container (Dynamic) -->
            <section class="game-container" id="gameContainer">
                <!-- Content will be dynamically loaded -->
            </section>
        </div>
    </div>

    <!-- Loading Spinner -->
    <div class="loading-spinner" id="loadingSpinner">
        <div class="spinner"></div>
    </div>

    <!-- Toast Notification -->
    <div class="toast" id="toast"></div>

    <!-- Confetti Container -->
    <div id="confettiContainer"></div>

    <!-- Game Over Overlay -->
    <div class="overlay" id="gameOverlay">
        <div class="overlay-content">
            <h2 id="overlayTitle">Congratulations!</h2>
            <p id="overlayMessage">You completed the puzzle!</p>
            <div class="controls">
                <button class="btn btn-primary" id="playAgain">
                    <i class="fas fa-redo"></i> Play Again
                </button>
                <button class="btn btn-secondary" id="overlayMenu">
                    <i class="fas fa-home"></i> Main Menu
                </button>
            </div>
        </div>
    </div>

    <!-- Stats Overlay -->
    <div class="overlay" id="statsOverlay">
        <div class="overlay-content">
            <h2><i class="fas fa-chart-bar"></i> Game Statistics</h2>
            <div id="statsContent" style="text-align: left; margin: 20px 0;">
                <!-- Stats will be loaded here -->
            </div>
            <div class="controls">
                <button class="btn btn-danger" id="clearStats">
                    <i class="fas fa-trash"></i> Clear Stats
                </button>
                <button class="btn btn-secondary" id="closeStats">
                    <i class="fas fa-times"></i> Close
                </button>
            </div>
        </div>
    </div>

    <script>
        // ==================== GLOBAL VARIABLES ====================
        const gameState = {
            currentGame: null,
            timer: 0,
            timerInterval: null,
            moves: 0,
            score: 0,
            gameActive: false,
            theme: 'dark',
            difficulty: 'medium',
            size: 'medium',
            stats: JSON.parse(localStorage.getItem('puzzleStats')) || {
                memory: { wins: 0, bestTime: 0, bestMoves: 0 },
                sliding: { wins: 0, bestTime: 0, bestMoves: 0 },
                sudoku: { wins: 0, bestTime: 0 },
                wordsearch: { wins: 0, bestTime: 0 },
                nonogram: { wins: 0, bestTime: 0 },
                match3: { wins: 0, highScore: 0 }
            },
            gameData: {}
        };

        // ==================== DOM ELEMENTS ====================
        const elements = {
            mainMenu: document.getElementById('mainMenu'),
            gameContainer: document.getElementById('gameContainer'),
            mainHeader: document.getElementById('mainHeader'),
            loadingSpinner: document.getElementById('loadingSpinner'),
            toast: document.getElementById('toast'),
            gameOverlay: document.getElementById('gameOverlay'),
            overlayTitle: document.getElementById('overlayTitle'),
            overlayMessage: document.getElementById('overlayMessage'),
            statsOverlay: document.getElementById('statsOverlay'),
            statsContent: document.getElementById('statsContent'),
            themeToggle: document.getElementById('themeToggle'),
            backToGames: document.getElementById('backToGames')
        };

        // ==================== UTILITY FUNCTIONS ====================
        function showLoading(show) {
            elements.loadingSpinner.style.display = show ? 'flex' : 'none';
        }

        function showToast(message, type = 'success') {
            const toast = elements.toast;
            toast.textContent = message;
            toast.style.borderColor = type === 'success' ? 'var(--success)' : 
                                    type === 'error' ? 'var(--accent)' : 'var(--warning)';
            toast.classList.add('show');
            
            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }

        function createConfetti() {
            const container = document.getElementById('confettiContainer');
            container.innerHTML = '';
            
            for (let i = 0; i < 100; i++) {
                const confetti = document.createElement('div');
                confetti.className = 'confetti';
                confetti.style.left = Math.random() * 100 + 'vw';
                confetti.style.background = `hsl(${Math.random() * 360}, 100%, 60%)`;
                confetti.style.width = Math.random() * 10 + 5 + 'px';
                confetti.style.height = Math.random() * 10 + 5 + 'px';
                confetti.style.animation = `confetti ${Math.random() * 2 + 1}s linear forwards`;
                container.appendChild(confetti);
                
                setTimeout(() => confetti.remove(), 2000);
            }
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        // ==================== GAME TEMPLATE ====================
        function createGameTemplate(gameName, instructions) {
            return `
                <div class="game-header">
                    <div class="game-title">
                        <i class="fas fa-gamepad"></i>
                        <span id="currentGameTitle">${gameName}</span>
                    </div>
                    <div class="game-stats">
                        <div class="stat-box">
                            <div class="stat-label">Time</div>
                            <div class="stat-value" id="timer">00:00</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-label">Moves</div>
                            <div class="stat-value" id="moveCount">0</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-label">Score</div>
                            <div class="stat-value" id="score">0</div>
                        </div>
                    </div>
                </div>

                <div class="game-content">
                    <div class="game-info-panel">
                        <div class="info-header">
                            <div class="difficulty-selector">
                                <button class="difficulty-btn" data-difficulty="easy">Easy</button>
                                <button class="difficulty-btn active" data-difficulty="medium">Normal</button>
                                <button class="difficulty-btn" data-difficulty="hard">Hard</button>
                            </div>
                            <button class="btn btn-success" id="showInstructionsBtn">
                                <i class="fas fa-info-circle"></i> Instructions
                            </button>
                        </div>
                        
                        <div class="game-instructions" id="instructionsPanel">
                            <h4><i class="fas fa-book"></i> How to Play</h4>
                            <p>${instructions}</p>
                            <p style="margin-top: 10px; color: var(--primary);">
                                <i class="fas fa-mobile-alt"></i> Tap on mobile or click on desktop to play!
                            </p>
                        </div>
                        
                        <div id="extraInfoPanel"></div>
                    </div>

                    <div class="game-board-container">
                        <div class="game-board" id="gameBoard">
                            <!-- Game board will be generated here -->
                        </div>
                    </div>

                    <div class="mobile-controls" id="mobileControls">
                        <!-- Mobile controls will be added for specific games -->
                    </div>

                    <div class="controls">
                        <button class="btn btn-primary" id="newGameBtn">
                            <i class="fas fa-redo"></i> New Game
                        </button>
                        <button class="btn btn-success" id="hintBtn">
                            <i class="fas fa-lightbulb"></i> Hint
                        </button>
                        <button class="btn btn-warning" id="undoBtn">
                            <i class="fas fa-undo"></i> Undo
                        </button>
                        <button class="btn btn-danger" id="quitBtn">
                            <i class="fas fa-home"></i> Quit
                        </button>
                    </div>
                </div>
            `;
        }

        // ==================== GAME INITIALIZATION ====================
        const gameInstructions = {
            memory: "Find all matching pairs of cards. Click/tap on two cards to reveal them. If they match, they stay face up. Remember the positions of cards to find matches faster!",
            sliding: "Arrange the numbered tiles in order from 1 to 15. Click/tap on a tile adjacent to the empty space to move it. Solve the puzzle in as few moves as possible!",
            sudoku: "Fill the grid so that each row, column, and 3x3 box contains all digits from 1 to 9. Use the number pad or tap numbers to fill cells. Gray cells are fixed.",
            wordsearch: "Find all the hidden words in the grid. Words can be horizontal, vertical, or diagonal. Click/tap and drag to select letters. Found words will be crossed off the list.",
            nonogram: "Fill cells to create a picture based on the number clues. Numbers on the sides tell you how many consecutive filled cells are in each row/column.",
            match3: "Swap adjacent gems to create rows or columns of 3 or more matching gems. Matched gems disappear and new gems fall from above. Score points for each match!"
        };

        function startGame(gameType) {
            if (gameType.startsWith('comingsoon')) {
                showToast('This game is coming soon! Try the other games first.', 'warning');
                return;
            }

            gameState.currentGame = gameType;
            gameState.timer = 0;
            gameState.moves = 0;
            gameState.score = 0;
            gameState.gameActive = true;
            
            showLoading(true);
            
            setTimeout(() => {
                elements.mainMenu.style.display = 'none';
                elements.gameContainer.style.display = 'block';
                elements.mainHeader.style.display = 'none';
                elements.backToGames.style.display = 'block';
                
                elements.gameContainer.innerHTML = createGameTemplate(
                    gameType.charAt(0).toUpperCase() + gameType.slice(1),
                    gameInstructions[gameType]
                );
                
                setupGameEventListeners();
                initializeGame(gameType);
                startTimer();
                showLoading(false);
            }, 500);
        }

        function setupGameEventListeners() {
            // Difficulty buttons
            document.querySelectorAll('.difficulty-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('.difficulty-btn').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    gameState.difficulty = this.dataset.difficulty;
                    initializeGame(gameState.currentGame);
                });
            });

            // Game control buttons
            document.getElementById('showInstructionsBtn')?.addEventListener('click', () => {
                const panel = document.getElementById('instructionsPanel');
                panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
            });

            document.getElementById('newGameBtn')?.addEventListener('click', () => {
                initializeGame(gameState.currentGame);
            });

            document.getElementById('hintBtn')?.addEventListener('click', showHint);
            document.getElementById('undoBtn')?.addEventListener('click', undoMove);
            document.getElementById('quitBtn')?.addEventListener('click', quitToMenu);

            // Overlay buttons
            document.getElementById('playAgain')?.addEventListener('click', () => {
                elements.gameOverlay.style.display = 'none';
                initializeGame(gameState.currentGame);
            });

            document.getElementById('overlayMenu')?.addEventListener('click', quitToMenu);
        }

        function startTimer() {
            clearInterval(gameState.timerInterval);
            gameState.timerInterval = setInterval(() => {
                if (gameState.gameActive) {
                    gameState.timer++;
                    const timerElement = document.getElementById('timer');
                    if (timerElement) timerElement.textContent = formatTime(gameState.timer);
                }
            }, 1000);
        }

        function updateStats() {
            const moveCount = document.getElementById('moveCount');
            const scoreElement = document.getElementById('score');
            
            if (moveCount) moveCount.textContent = gameState.moves;
            if (scoreElement) scoreElement.textContent = gameState.score;
        }

        // ==================== INDIVIDUAL GAME IMPLEMENTATIONS ====================

        // 1. MEMORY GAME
        function initializeMemoryGame() {
            gameState.gameData = {
                flippedCards: [],
                matchedPairs: 0,
                canFlip: true
            };

            const sizes = { easy: 4, medium: 6, hard: 8 };
            const size = sizes[gameState.difficulty] || 4;
            const totalPairs = (size * size) / 2;
            
            const symbols = ['â­', 'ðŸŒŸ', 'ðŸŒ™', 'â˜€ï¸', 'ðŸŒˆ', 'âš¡', 'ðŸ’Ž', 'ðŸŽ¯', 'â¤ï¸', 'âœ¨', 'ðŸŽ®', 'ðŸ†', 'ðŸŽ¨', 'ðŸš€', 'ðŸ‘¾', 'ðŸŽª'];
            const selectedSymbols = symbols.slice(0, totalPairs);
            const cards = [...selectedSymbols, ...selectedSymbols];
            
            // Shuffle
            for (let i = cards.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [cards[i], cards[j]] = [cards[j], cards[i]];
            }

            const board = document.getElementById('gameBoard');
            const extraInfo = document.getElementById('extraInfoPanel');
            
            board.className = 'game-board memory-grid';
            board.style.gridTemplateColumns = `repeat(${size}, 1fr)`;
            board.style.gridTemplateRows = `repeat(${size}, 1fr)`;
            board.innerHTML = '';
            
            extraInfo.innerHTML = `
                <div style="text-align: center; margin-top: 10px; color: var(--text-secondary);">
                    <i class="fas fa-brain"></i> Find ${totalPairs} matching pairs
                </div>
            `;

            cards.forEach((symbol, index) => {
                const card = document.createElement('div');
                card.className = 'tile memory-card';
                card.dataset.index = index;
                card.dataset.symbol = symbol;
                
                const inner = document.createElement('div');
                inner.className = 'memory-card-inner';
                
                const front = document.createElement('div');
                front.className = 'memory-card-front';
                front.innerHTML = '<i class="fas fa-question"></i>';
                
                const back = document.createElement('div');
                back.className = 'memory-card-back';
                back.textContent = symbol;
                
                inner.appendChild(front);
                inner.appendChild(back);
                card.appendChild(inner);
                
                card.addEventListener('click', () => handleMemoryCardClick(card));
                board.appendChild(card);
            });
        }

        function handleMemoryCardClick(card) {
            if (!gameState.gameActive || !gameState.gameData.canFlip || 
                card.classList.contains('flipped') || 
                gameState.gameData.flippedCards.length >= 2) return;
            
            card.classList.add('flipped');
            gameState.gameData.flippedCards.push(card);
            
            if (gameState.gameData.flippedCards.length === 2) {
                gameState.gameData.canFlip = false;
                gameState.moves++;
                updateStats();
                
                const [card1, card2] = gameState.gameData.flippedCards;
                const match = card1.dataset.symbol === card2.dataset.symbol;
                
                setTimeout(() => {
                    if (match) {
                        card1.classList.add('matched');
                        card2.classList.add('matched');
                        gameState.gameData.matchedPairs++;
                        
                        if (gameState.gameData.matchedPairs === gameState.gameData.flippedCards.length / 2) {
                            gameWon();
                        }
                    } else {
                        card1.classList.remove('flipped');
                        card2.classList.remove('flipped');
                    }
                    
                    gameState.gameData.flippedCards = [];
                    gameState.gameData.canFlip = true;
                }, 1000);
            }
        }

        // 2. SLIDING PUZZLE
        function initializeSlidingPuzzle() {
            const sizes = { easy: 3, medium: 4, hard: 5 };
            const size = sizes[gameState.difficulty] || 4;
            const totalTiles = size * size - 1;
            
            let numbers = Array.from({length: totalTiles}, (_, i) => i + 1);
            numbers.push(null); // Empty space
            
            // Make sure puzzle is solvable
            do {
                for (let i = numbers.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [numbers[i], numbers[j]] = [numbers[j], numbers[i]];
                }
            } while (!isSlidingPuzzleSolvable(numbers, size));
            
            gameState.gameData = {
                numbers: numbers,
                size: size,
                emptyIndex: numbers.indexOf(null),
                moveHistory: []
            };

            const board = document.getElementById('gameBoard');
            board.className = 'game-board sliding-grid';
            board.style.gridTemplateColumns = `repeat(${size}, 1fr)`;
            board.style.gridTemplateRows = `repeat(${size}, 1fr)`;
            board.innerHTML = '';
            
            const extraInfo = document.getElementById('extraInfoPanel');
            extraInfo.innerHTML = `
                <div style="text-align: center; margin-top: 10px; color: var(--text-secondary);">
                    <i class="fas fa-arrows-alt"></i> Arrange numbers 1-${totalTiles} in order
                </div>
            `;

            numbers.forEach((num, index) => {
                const tile = document.createElement('div');
                tile.className = num ? 'tile' : 'tile empty';
                tile.textContent = num;
                tile.dataset.index = index;
                
                if (num) {
                    tile.addEventListener('click', () => handleSlidingTileClick(index));
                }
                
                board.appendChild(tile);
            });
        }

        function isSlidingPuzzleSolvable(numbers, size) {
            // Check if puzzle is solvable (for odd-sized grids)
            const flatNumbers = numbers.filter(n => n !== null);
            let inversions = 0;
            
            for (let i = 0; i < flatNumbers.length; i++) {
                for (let j = i + 1; j < flatNumbers.length; j++) {
                    if (flatNumbers[i] > flatNumbers[j]) inversions++;
                }
            }
            
            return inversions % 2 === 0;
        }

        function handleSlidingTileClick(index) {
            if (!gameState.gameActive) return;
            
            const emptyIndex = gameState.gameData.emptyIndex;
            const size = gameState.gameData.size;
            const row = Math.floor(index / size);
            const col = index % size;
            const emptyRow = Math.floor(emptyIndex / size);
            const emptyCol = emptyIndex % size;
            
            const isAdjacent = (Math.abs(row - emptyRow) === 1 && col === emptyCol) ||
                              (Math.abs(col - emptyCol) === 1 && row === emptyRow);
            
            if (isAdjacent) {
                // Save move for undo
                gameState.gameData.moveHistory.push({
                    numbers: [...gameState.gameData.numbers],
                    emptyIndex: emptyIndex
                });
                
                // Swap tiles
                gameState.gameData.numbers[emptyIndex] = gameState.gameData.numbers[index];
                gameState.gameData.numbers[index] = null;
                gameState.gameData.emptyIndex = index;
                
                // Update display
                updateSlidingPuzzleDisplay();
                
                gameState.moves++;
                updateStats();
                
                // Check win
                if (checkSlidingPuzzleWin()) {
                    gameWon();
                }
            }
        }

        function updateSlidingPuzzleDisplay() {
            const tiles = document.querySelectorAll('#gameBoard .tile');
            gameState.gameData.numbers.forEach((num, index) => {
                const tile = tiles[index];
                tile.textContent = num;
                tile.className = num ? 'tile' : 'tile empty';
                
                // Update click event
                tile.onclick = num ? () => handleSlidingTileClick(index) : null;
            });
        }

        function checkSlidingPuzzleWin() {
            const numbers = gameState.gameData.numbers.slice(0, -1);
            for (let i = 0; i < numbers.length; i++) {
                if (numbers[i] !== i + 1) return false;
            }
            return true;
        }

        // 3. SUDOKU
        function initializeSudoku() {
            const difficulties = {
                easy: 40,   // Numbers to remove
                medium: 50,
                hard: 60
            };
            
            const removeCount = difficulties[gameState.difficulty] || 40;
            
            // Generate a solved Sudoku puzzle
            const solution = generateSudokuSolution();
            const puzzle = createSudokuPuzzle(solution, removeCount);
            
            gameState.gameData = {
                solution: solution,
                puzzle: puzzle,
                selectedCell: null,
                mistakes: 0,
                moveHistory: []
            };

            const board = document.getElementById('gameBoard');
            board.className = 'game-board sudoku-grid';
            board.style.gridTemplateColumns = 'repeat(9, 1fr)';
            board.style.gridTemplateRows = 'repeat(9, 1fr)';
            board.innerHTML = '';
            
            const extraInfo = document.getElementById('extraInfoPanel');
            extraInfo.innerHTML = `
                <div style="text-align: center; margin-top: 10px;">
                    <button class="btn btn-secondary" id="numberPad" style="margin: 5px;">
                        <i class="fas fa-keyboard"></i> Show Number Pad
                    </button>
                    <div id="numberPadContainer" style="display: none; margin-top: 10px;">
                        <div style="display: flex; flex-wrap: wrap; gap: 5px; justify-content: center;">
                            ${Array.from({length: 9}, (_, i) => 
                                `<button class="number-btn" data-number="${i + 1}">${i + 1}</button>`
                            ).join('')}
                            <button class="number-btn" data-number="0">Clear</button>
                        </div>
                    </div>
                </div>
            `;

            // Create cells
            for (let i = 0; i < 81; i++) {
                const cell = document.createElement('div');
                cell.className = 'tile sudoku-cell';
                cell.dataset.row = Math.floor(i / 9);
                cell.dataset.col = i % 9;
                cell.dataset.index = i;
                
                const value = puzzle[Math.floor(i / 9)][i % 9];
                if (value !== 0) {
                    cell.textContent = value;
                    cell.classList.add('locked');
                    cell.style.color = 'var(--primary)';
                    cell.style.fontWeight = 'bold';
                } else {
                    cell.contentEditable = true;
                    cell.addEventListener('focus', () => handleSudokuCellFocus(cell));
                    cell.addEventListener('input', (e) => handleSudokuCellInput(e, cell));
                }
                
                board.appendChild(cell);
            }

            // Number pad event listeners
            document.getElementById('numberPad')?.addEventListener('click', () => {
                const pad = document.getElementById('numberPadContainer');
                pad.style.display = pad.style.display === 'none' ? 'block' : 'none';
            });

            document.querySelectorAll('.number-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const number = parseInt(btn.dataset.number);
                    if (gameState.gameData.selectedCell) {
                        const cell = gameState.gameData.selectedCell;
                        if (number === 0) {
                            cell.textContent = '';
                        } else {
                            cell.textContent = number;
                        }
                        handleSudokuCellInput({ target: cell }, cell);
                    }
                });
            });
        }

        function generateSudokuSolution() {
            const grid = Array(9).fill().map(() => Array(9).fill(0));
            
            // Fill diagonal 3x3 boxes
            for (let i = 0; i < 9; i += 3) {
                fillBox(grid, i, i);
            }
            
            // Fill remaining cells
            solveSudoku(grid);
            return grid;
        }

        function fillBox(grid, row, col) {
            const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];
            // Shuffle
            for (let i = numbers.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [numbers[i], numbers[j]] = [numbers[j], numbers[i]];
            }
            
            let index = 0;
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 3; j++) {
                    grid[row + i][col + j] = numbers[index++];
                }
            }
        }

        function solveSudoku(grid) {
            for (let row = 0; row < 9; row++) {
                for (let col = 0; col < 9; col++) {
                    if (grid[row][col] === 0) {
                        const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];
                        // Shuffle
                        for (let i = numbers.length - 1; i > 0; i--) {
                            const j = Math.floor(Math.random() * (i + 1));
                            [numbers[i], numbers[j]] = [numbers[j], numbers[i]];
                        }
                        
                        for (const num of numbers) {
                            if (isValidSudokuMove(grid, row, col, num)) {
                                grid[row][col] = num;
                                if (solveSudoku(grid)) return true;
                                grid[row][col] = 0;
                            }
                        }
                        return false;
                    }
                }
            }
            return true;
        }

        function isValidSudokuMove(grid, row, col, num) {
            // Check row
            for (let x = 0; x < 9; x++) {
                if (grid[row][x] === num) return false;
            }
            
            // Check column
            for (let x = 0; x < 9; x++) {
                if (grid[x][col] === num) return false;
            }
            
            // Check 3x3 box
            const boxRow = Math.floor(row / 3) * 3;
            const boxCol = Math.floor(col / 3) * 3;
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 3; j++) {
                    if (grid[boxRow + i][boxCol + j] === num) return false;
                }
            }
            
            return true;
        }

        function createSudokuPuzzle(solution, removeCount) {
            const puzzle = solution.map(row => [...row]);
            let removed = 0;
            
            while (removed < removeCount) {
                const row = Math.floor(Math.random() * 9);
                const col = Math.floor(Math.random() * 9);
                
                if (puzzle[row][col] !== 0) {
                    const backup = puzzle[row][col];
                    puzzle[row][col] = 0;
                    
                    // Check if puzzle still has unique solution
                    const tempGrid = puzzle.map(row => [...row]);
                    if (countSolutions(tempGrid) === 1) {
                        removed++;
                    } else {
                        puzzle[row][col] = backup;
                    }
                }
            }
            
            return puzzle;
        }

        function countSolutions(grid) {
            let solutions = 0;
            
            function solve() {
                for (let row = 0; row < 9; row++) {
                    for (let col = 0; col < 9; col++) {
                        if (grid[row][col] === 0) {
                            for (let num = 1; num <= 9; num++) {
                                if (isValidSudokuMove(grid, row, col, num)) {
                                    grid[row][col] = num;
                                    if (solve()) {
                                        if (++solutions > 1) return true;
                                    }
                                    grid[row][col] = 0;
                                }
                            }
                            return solutions > 0;
                        }
                    }
                }
                solutions++;
                return solutions > 0;
            }
            
            solve();
            return solutions;
        }

        function handleSudokuCellFocus(cell) {
            document.querySelectorAll('.sudoku-cell.selected').forEach(c => c.classList.remove('selected'));
            cell.classList.add('selected');
            gameState.gameData.selectedCell = cell;
        }

        function handleSudokuCellInput(event, cell) {
            const value = event.target.textContent;
            if (value && !/^[1-9]$/.test(value)) {
                cell.textContent = '';
                return;
            }
            
            if (value) {
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                const num = parseInt(value);
                
                // Save move for undo
                gameState.gameData.moveHistory.push({
                    row: row,
                    col: col,
                    previous: 0,
                    current: num
                });
                
                // Check if correct
                if (gameState.gameData.solution[row][col] === num) {
                    cell.classList.remove('wrong');
                    cell.classList.add('correct');
                    cell.style.color = 'var(--success)';
                    
                    // Check if puzzle complete
                    if (checkSudokuComplete()) {
                        gameWon();
                    }
                } else {
                    cell.classList.remove('correct');
                    cell.classList.add('wrong');
                    cell.style.color = 'var(--accent)';
                    gameState.gameData.mistakes++;
                    
                    if (gameState.gameData.mistakes >= 5) {
                        showToast('Too many mistakes! Try again.', 'error');
                        setTimeout(() => initializeSudoku(), 1000);
                    }
                }
                
                gameState.moves++;
                updateStats();
            }
        }

        function checkSudokuComplete() {
            const cells = document.querySelectorAll('.sudoku-cell');
            for (const cell of cells) {
                if (!cell.textContent || cell.classList.contains('wrong')) {
                    return false;
                }
            }
            return true;
        }

        // 4. WORD SEARCH
        function initializeWordSearch() {
            const wordLists = {
                easy: ['HTML', 'CSS', 'JS', 'WEB', 'GAME', 'CODE', 'FUN', 'PLAY'],
                medium: ['JAVASCRIPT', 'PROGRAMMING', 'DEVELOPER', 'BROWSER', 'COMPUTER', 'SOFTWARE', 'HARDWARE', 'NETWORK'],
                hard: ['ALGORITHM', 'DATABASE', 'FRAMEWORK', 'INTERFACE', 'PLATFORM', 'SECURITY', 'VARIABLE', 'FUNCTION']
            };
            
            const words = wordLists[gameState.difficulty] || wordLists.medium;
            const gridSize = gameState.difficulty === 'easy' ? 8 : gameState.difficulty === 'medium' ? 10 : 12;
            
            const grid = Array(gridSize).fill().map(() => Array(gridSize).fill(''));
            const placedWords = [];
            
            // Try to place each word
            words.forEach(word => {
                let placed = false;
                let attempts = 0;
                
                while (!placed && attempts < 100) {
                    const direction = Math.floor(Math.random() * 3); // 0: horizontal, 1: vertical, 2: diagonal
                    const row = Math.floor(Math.random() * gridSize);
                    const col = Math.floor(Math.random() * gridSize);
                    
                    if (canPlaceWord(grid, word, row, col, direction)) {
                        placeWord(grid, word, row, col, direction);
                        placedWords.push({ word, direction, row, col });
                        placed = true;
                    }
                    attempts++;
                }
            });
            
            // Fill empty spaces with random letters
            const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    if (!grid[i][j]) {
                        grid[i][j] = alphabet[Math.floor(Math.random() * alphabet.length)];
                    }
                }
            }
            
            gameState.gameData = {
                grid: grid,
                words: words,
                placedWords: placedWords,
                foundWords: [],
                selectedCells: [],
                isSelecting: false
            };

            const board = document.getElementById('gameBoard');
            board.className = 'game-board';
            board.style.gridTemplateColumns = `repeat(${gridSize}, 1fr)`;
            board.style.gridTemplateRows = `repeat(${gridSize}, 1fr)`;
            board.innerHTML = '';
            
            const extraInfo = document.getElementById('extraInfoPanel');
            extraInfo.innerHTML = `
                <div class="word-list-container">
                    <h4><i class="fas fa-list"></i> Words to Find</h4>
                    <div class="word-list" id="wordList">
                        ${words.map(word => 
                            `<span class="word-item" data-word="${word}">${word}</span>`
                        ).join('')}
                    </div>
                </div>
            `;

            // Create grid cells
            for (let i = 0; i < gridSize * gridSize; i++) {
                const row = Math.floor(i / gridSize);
                const col = i % gridSize;
                const cell = document.createElement('div');
                cell.className = 'tile wordsearch-cell';
                cell.textContent = grid[row][col];
                cell.dataset.row = row;
                cell.dataset.col = col;
                
                // Touch/click events
                cell.addEventListener('mousedown', (e) => startWordSelection(e, cell));
                cell.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    startWordSelection(e, cell);
                });
                
                cell.addEventListener('mouseover', (e) => continueWordSelection(e, cell));
                cell.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    const element = document.elementFromPoint(touch.clientX, touch.clientY);
                    if (element && element.classList.contains('wordsearch-cell')) {
                        continueWordSelection(e, element);
                    }
                });
                
                cell.addEventListener('mouseup', endWordSelection);
                cell.addEventListener('touchend', endWordSelection);
                
                board.appendChild(cell);
            }
        }

        function canPlaceWord(grid, word, row, col, direction) {
            const gridSize = grid.length;
            
            if (direction === 0) { // horizontal
                if (col + word.length > gridSize) return false;
                for (let i = 0; i < word.length; i++) {
                    if (grid[row][col + i] && grid[row][col + i] !== word[i]) return false;
                }
            } else if (direction === 1) { // vertical
                if (row + word.length > gridSize) return false;
                for (let i = 0; i < word.length; i++) {
                    if (grid[row + i][col] && grid[row + i][col] !== word[i]) return false;
                }
            } else { // diagonal
                if (row + word.length > gridSize || col + word.length > gridSize) return false;
                for (let i = 0; i < word.length; i++) {
                    if (grid[row + i][col + i] && grid[row + i][col + i] !== word[i]) return false;
                }
            }
            
            return true;
        }

        function placeWord(grid, word, row, col, direction) {
            if (direction === 0) { // horizontal
                for (let i = 0; i < word.length; i++) {
                    grid[row][col + i] = word[i];
                }
            } else if (direction === 1) { // vertical
                for (let i = 0; i < word.length; i++) {
                    grid[row + i][col] = word[i];
                }
            } else { // diagonal
                for (let i = 0; i < word.length; i++) {
                    grid[row + i][col + i] = word[i];
                }
            }
        }

        function startWordSelection(event, cell) {
            event.preventDefault();
            if (!gameState.gameActive) return;
            
            gameState.gameData.isSelecting = true;
            gameState.gameData.selectedCells = [cell];
            cell.classList.add('selected');
        }

        function continueWordSelection(event, cell) {
            event.preventDefault();
            if (!gameState.gameData.isSelecting) return;
            
            if (!gameState.gameData.selectedCells.includes(cell)) {
                gameState.gameData.selectedCells.push(cell);
                cell.classList.add('selected');
            }
        }

        function endWordSelection() {
            if (!gameState.gameData.isSelecting) return;
            
            gameState.gameData.isSelecting = false;
            
            // Get the selected word
            const selectedWord = gameState.gameData.selectedCells
                .map(cell => cell.textContent)
                .join('');
            
            // Check if it matches any word
            const matchedWord = gameState.gameData.words.find(word => 
                word === selectedWord || word === selectedWord.split('').reverse().join('')
            );
            
            if (matchedWord && !gameState.gameData.foundWords.includes(matchedWord)) {
                // Word found!
                gameState.gameData.foundWords.push(matchedWord);
                gameState.gameData.selectedCells.forEach(cell => cell.classList.add('matched'));
                
                // Update word list
                const wordItem = document.querySelector(`.word-item[data-word="${matchedWord}"]`);
                if (wordItem) wordItem.classList.add('found');
                
                gameState.score += matchedWord.length * 10;
                gameState.moves++;
                updateStats();
                
                showToast(`Found: ${matchedWord}!`, 'success');
                
                // Check if all words found
                if (gameState.gameData.foundWords.length === gameState.gameData.words.length) {
                    setTimeout(() => gameWon(), 500);
                }
            } else {
                // Wrong selection
                gameState.gameData.selectedCells.forEach(cell => {
                    cell.classList.remove('selected');
                    setTimeout(() => cell.classList.remove('selected'), 300);
                });
                gameState.moves++;
                updateStats();
            }
            
            gameState.gameData.selectedCells = [];
        }

        // 5. NONOGRAM
        function initializeNonogram() {
            const sizes = { easy: 5, medium: 8, hard: 10 };
            const size = sizes[gameState.difficulty] || 8;
            
            // Generate a simple pattern
            const solution = generateNonogramSolution(size);
            const rowClues = calculateRowClues(solution);
            const colClues = calculateColumnClues(solution);
            
            gameState.gameData = {
                solution: solution,
                currentGrid: Array(size).fill().map(() => Array(size).fill(0)),
                rowClues: rowClues,
                colClues: colClues,
                mistakes: 0
            };

            const board = document.getElementById('gameBoard');
            const totalSize = size + Math.max(...colClues.map(c => c.length));
            board.className = 'game-board nonogram-grid';
            board.style.gridTemplateColumns = `repeat(${totalSize}, 1fr)`;
            board.style.gridTemplateRows = `repeat(${totalSize}, 1fr)`;
            board.innerHTML = '';
            
            const extraInfo = document.getElementById('extraInfoPanel');
            extraInfo.innerHTML = `
                <div style="text-align: center; margin-top: 10px; color: var(--text-secondary);">
                    <i class="fas fa-mouse-pointer"></i> Click to fill, Right-click to mark X
                </div>
            `;

            // Create grid with clues
            // Column clues (top)
            colClues.forEach((clue, colIndex) => {
                clue.forEach((number, clueIndex) => {
                    const cell = document.createElement('div');
                    cell.className = 'tile';
                    cell.textContent = number || '';
                    cell.style.background = 'var(--bg)';
                    cell.style.fontSize = '0.8rem';
                    cell.style.gridColumn = colIndex + 1 + Math.max(...colClues.map(c => c.length)) - clue.length;
                    cell.style.gridRow = clueIndex + 1;
                    board.appendChild(cell);
                });
            });
            
            // Row clues (left)
            rowClues.forEach((clue, rowIndex) => {
                clue.forEach((number, clueIndex) => {
                    const cell = document.createElement('div');
                    cell.className = 'tile';
                    cell.textContent = number || '';
                    cell.style.background = 'var(--bg)';
                    cell.style.fontSize = '0.8rem';
                    cell.style.gridColumn = clueIndex + 1;
                    cell.style.gridRow = rowIndex + 1 + Math.max(...colClues.map(c => c.length));
                    board.appendChild(cell);
                });
            });
            
            // Game grid
            for (let row = 0; row < size; row++) {
                for (let col = 0; col < size; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'tile nonogram-cell';
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    cell.style.gridColumn = col + 1 + Math.max(...colClues.map(c => c.length));
                    cell.style.gridRow = row + 1 + Math.max(...colClues.map(c => c.length));
                    
                    cell.addEventListener('click', (e) => handleNonogramClick(e, cell, true));
                    cell.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        handleNonogramClick(e, cell, false);
                    });
                    
                    // Touch events for mobile
                    let tapTimer;
                    cell.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        tapTimer = setTimeout(() => {
                            handleNonogramClick(e, cell, false);
                        }, 500);
                    });
                    
                    cell.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        clearTimeout(tapTimer);
                        handleNonogramClick(e, cell, true);
                    });
                    
                    board.appendChild(cell);
                }
            }
        }

        function generateNonogramSolution(size) {
            const grid = Array(size).fill().map(() => Array(size).fill(0));
            
            // Create a simple pattern (a cross)
            const center = Math.floor(size / 2);
            for (let i = 0; i < size; i++) {
                grid[center][i] = 1; // Horizontal line
                grid[i][center] = 1; // Vertical line
            }
            
            // Add some random cells
            for (let i = 0; i < size * 2; i++) {
                const row = Math.floor(Math.random() * size);
                const col = Math.floor(Math.random() * size);
                grid[row][col] = 1;
            }
            
            return grid;
        }

        function calculateRowClues(grid) {
            return grid.map(row => {
                const clues = [];
                let count = 0;
                
                for (const cell of row) {
                    if (cell === 1) {
                        count++;
                    } else if (count > 0) {
                        clues.push(count);
                        count = 0;
                    }
                }
                
                if (count > 0) clues.push(count);
                return clues.length > 0 ? clues : [0];
            });
        }

        function calculateColumnClues(grid) {
            const size = grid.length;
            const clues = [];
            
            for (let col = 0; col < size; col++) {
                const columnClues = [];
                let count = 0;
                
                for (let row = 0; row < size; row++) {
                    if (grid[row][col] === 1) {
                        count++;
                    } else if (count > 0) {
                        columnClues.push(count);
                        count = 0;
                    }
                }
                
                if (count > 0) columnClues.push(count);
                clues.push(columnClues.length > 0 ? columnClues : [0]);
            }
            
            return clues;
        }

        function handleNonogramClick(event, cell, isFill) {
            if (!gameState.gameActive) return;
            
            const row = parseInt(cell.dataset.row);
            const col = parseInt(cell.dataset.col);
            
            if (isFill) {
                // Fill cell
                cell.classList.toggle('filled');
                gameState.gameData.currentGrid[row][col] = cell.classList.contains('filled') ? 1 : 0;
                
                // Check if correct
                if (cell.classList.contains('filled') && gameState.gameData.solution[row][col] !== 1) {
                    cell.classList.add('wrong');
                    gameState.gameData.mistakes++;
                    
                    if (gameState.gameData.mistakes >= 3) {
                        showToast('Too many mistakes! Try again.', 'error');
                        setTimeout(() => initializeNonogram(), 1000);
                    }
                } else {
                    cell.classList.remove('wrong');
                }
            } else {
                // Mark with X
                cell.classList.toggle('marked');
                cell.textContent = cell.classList.contains('marked') ? 'X' : '';
            }
            
            gameState.moves++;
            updateStats();
            
            // Check win
            if (checkNonogramWin()) {
                gameWon();
            }
        }

        function checkNonogramWin() {
            const size = gameState.gameData.solution.length;
            
            for (let row = 0; row < size; row++) {
                for (let col = 0; col < size; col++) {
                    const shouldBeFilled = gameState.gameData.solution[row][col] === 1;
                    const isFilled = gameState.gameData.currentGrid[row][col] === 1;
                    
                    if (shouldBeFilled !== isFilled) {
                        return false;
                    }
                }
            }
            
            return true;
        }

        // 6. MATCH-3 GAME
        function initializeMatch3() {
            const gridSize = 8;
            const gemTypes = ['ðŸ’Ž', 'ðŸ”®', 'ðŸŒŸ', 'ðŸ’–', 'âœ¨', 'âš¡'];
            
            // Create initial board with no matches
            let board;
            do {
                board = Array(gridSize).fill().map(() => 
                    Array(gridSize).fill().map(() => 
                        gemTypes[Math.floor(Math.random() * gemTypes.length)]
                    )
                );
            } while (findMatches(board).length > 0);
            
            gameState.gameData = {
                board: board,
                selectedGem: null,
                score: 0,
                moveHistory: []
            };

            const boardElement = document.getElementById('gameBoard');
            boardElement.className = 'game-board match3-grid';
            boardElement.style.gridTemplateColumns = `repeat(${gridSize}, 1fr)`;
            boardElement.style.gridTemplateRows = `repeat(${gridSize}, 1fr)`;
            
            updateMatch3Display();
            
            const extraInfo = document.getElementById('extraInfoPanel');
            extraInfo.innerHTML = `
                <div style="text-align: center; margin-top: 10px; color: var(--text-secondary);">
                    <i class="fas fa-exchange-alt"></i> Swap adjacent gems to make matches of 3 or more
                </div>
            `;
        }

        function updateMatch3Display() {
            const boardElement = document.getElementById('gameBoard');
            boardElement.innerHTML = '';
            
            gameState.gameData.board.forEach((row, rowIndex) => {
                row.forEach((gem, colIndex) => {
                    const gemElement = document.createElement('div');
                    gemElement.className = 'tile match3-gem';
                    gemElement.textContent = gem;
                    gemElement.dataset.row = rowIndex;
                    gemElement.dataset.col = colIndex;
                    
                    if (gameState.gameData.selectedGem && 
                        gameState.gameData.selectedGem.row === rowIndex && 
                        gameState.gameData.selectedGem.col === colIndex) {
                        gemElement.classList.add('selected');
                    }
                    
                    gemElement.addEventListener('click', () => handleMatch3Click(rowIndex, colIndex));
                    boardElement.appendChild(gemElement);
                });
            });
        }

        function handleMatch3Click(row, col) {
            if (!gameState.gameActive) return;
            
            if (!gameState.gameData.selectedGem) {
                // First selection
                gameState.gameData.selectedGem = { row, col };
                updateMatch3Display();
            } else {
                // Second selection - check if adjacent
                const first = gameState.gameData.selectedGem;
                const isAdjacent = 
                    (Math.abs(first.row - row) === 1 && first.col === col) ||
                    (Math.abs(first.col - col) === 1 && first.row === row);
                
                if (isAdjacent) {
                    // Save move for undo
                    gameState.gameData.moveHistory.push({
                        board: gameState.gameData.board.map(row => [...row]),
                        score: gameState.gameData.score
                    });
                    
                    // Swap gems
                    const temp = gameState.gameData.board[first.row][first.col];
                    gameState.gameData.board[first.row][first.col] = gameState.gameData.board[row][col];
                    gameState.gameData.board[row][col] = temp;
                    
                    // Check for matches
                    const matches = findMatches(gameState.gameData.board);
                    
                    if (matches.length > 0) {
                        // Valid move
                        gameState.moves++;
                        processMatches(matches);
                    } else {
                        // No matches, swap back
                        gameState.gameData.board[row][col] = gameState.gameData.board[first.row][first.col];
                        gameState.gameData.board[first.row][first.col] = temp;
                        showToast('No matches found! Try another swap.', 'warning');
                    }
                }
                
                gameState.gameData.selectedGem = null;
                updateMatch3Display();
                updateStats();
            }
        }

        function findMatches(board) {
            const matches = [];
            const gridSize = board.length;
            
            // Check horizontal matches
            for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize - 2; col++) {
                    const gem = board[row][col];
                    if (gem && 
                        gem === board[row][col + 1] && 
                        gem === board[row][col + 2]) {
                        
                        let matchEnd = col + 2;
                        while (matchEnd + 1 < gridSize && board[row][matchEnd + 1] === gem) {
                            matchEnd++;
                        }
                        
                        matches.push({
                            row: row,
                            start: col,
                            end: matchEnd,
                            direction: 'horizontal'
                        });
                        
                        col = matchEnd;
                    }
                }
            }
            
            // Check vertical matches
            for (let col = 0; col < gridSize; col++) {
                for (let row = 0; row < gridSize - 2; row++) {
                    const gem = board[row][col];
                    if (gem && 
                        gem === board[row + 1][col] && 
                        gem === board[row + 2][col]) {
                        
                        let matchEnd = row + 2;
                        while (matchEnd + 1 < gridSize && board[matchEnd + 1][col] === gem) {
                            matchEnd++;
                        }
                        
                        matches.push({
                            col: col,
                            start: row,
                            end: matchEnd,
                            direction: 'vertical'
                        });
                        
                        row = matchEnd;
                    }
                }
            }
            
            return matches;
        }

        function processMatches(matches) {
            const gemTypes = ['ðŸ’Ž', 'ðŸ”®', 'ðŸŒŸ', 'ðŸ’–', 'âœ¨', 'âš¡'];
            const gridSize = gameState.gameData.board.length;
            
            // Remove matched gems
            matches.forEach(match => {
                if (match.direction === 'horizontal') {
                    for (let col = match.start; col <= match.end; col++) {
                        gameState.gameData.board[match.row][col] = null;
                    }
                } else {
                    for (let row = match.start; row <= match.end; row++) {
                        gameState.gameData.board[row][match.col] = null;
                    }
                }
                
                // Add score
                const matchLength = match.end - match.start + 1;
                gameState.gameData.score += matchLength * 10;
                gameState.score = gameState.gameData.score;
            });
            
            // Drop gems down
            for (let col = 0; col < gridSize; col++) {
                let emptySpaces = 0;
                for (let row = gridSize - 1; row >= 0; row--) {
                    if (gameState.gameData.board[row][col] === null) {
                        emptySpaces++;
                    } else if (emptySpaces > 0) {
                        gameState.gameData.board[row + emptySpaces][col] = gameState.gameData.board[row][col];
                        gameState.gameData.board[row][col] = null;
                    }
                }
            }
            
            // Fill empty spaces with new gems
            for (let col = 0; col < gridSize; col++) {
                for (let row = 0; row < gridSize; row++) {
                    if (gameState.gameData.board[row][col] === null) {
                        gameState.gameData.board[row][col] = gemTypes[Math.floor(Math.random() * gemTypes.length)];
                    }
                }
            }
            
            // Check for new matches
            updateMatch3Display();
            const newMatches = findMatches(gameState.gameData.board);
            if (newMatches.length > 0) {
                setTimeout(() => processMatches(newMatches), 500);
            }
        }

        // ==================== GAME MANAGEMENT ====================
        function initializeGame(gameType) {
            gameState.moves = 0;
            gameState.score = 0;
            gameState.timer = 0;
            gameState.gameActive = true;
            
            clearInterval(gameState.timerInterval);
            startTimer();
            updateStats();
            
            switch(gameType) {
                case 'memory':
                    initializeMemoryGame();
                    break;
                case 'sliding':
                    initializeSlidingPuzzle();
                    break;
                case 'sudoku':
                    initializeSudoku();
                    break;
                case 'wordsearch':
                    initializeWordSearch();
                    break;
                case 'nonogram':
                    initializeNonogram();
                    break;
                case 'match3':
                    initializeMatch3();
                    break;
                default:
                    showToast('Game coming soon!', 'warning');
                    quitToMenu();
            }
        }

        function showHint() {
            if (!gameState.gameActive) return;
            
            const hints = {
                memory: "Try to remember the positions of cards you've already seen. Focus on one area at a time.",
                sliding: "Work on getting the first row in order, then the first column, and continue systematically.",
                sudoku: "Look for rows, columns, or boxes that are almost complete. Use process of elimination.",
                wordsearch: "Scan for the first letter of each word. Look for unusual letter combinations.",
                nonogram: "Start with rows and columns that have large numbers or are completely filled.",
                match3: "Look for potential matches that will create cascading combos for higher scores."
            };
            
            showToast(hints[gameState.currentGame] || "Take your time and think ahead!", 'warning');
            gameState.moves += 3; // Penalty for using hint
            updateStats();
        }

        function undoMove() {
            if (!gameState.gameActive || !gameState.gameData.moveHistory || gameState.gameData.moveHistory.length === 0) {
                showToast('No moves to undo!', 'warning');
                return;
            }
            
            const lastMove = gameState.gameData.moveHistory.pop();
            
            switch(gameState.currentGame) {
                case 'sliding':
                    gameState.gameData.numbers = lastMove.numbers;
                    gameState.gameData.emptyIndex = lastMove.emptyIndex;
                    updateSlidingPuzzleDisplay();
                    break;
                case 'sudoku':
                    // Implement undo for Sudoku
                    break;
                case 'match3':
                    gameState.gameData.board = lastMove.board;
                    gameState.gameData.score = lastMove.score;
                    gameState.score = lastMove.score;
                    updateMatch3Display();
                    break;
            }
            
            gameState.moves++;
            updateStats();
            showToast('Move undone!', 'success');
        }

        function gameWon() {
            gameState.gameActive = false;
            clearInterval(gameState.timerInterval);
            
            // Update statistics
            if (gameState.stats[gameState.currentGame]) {
                const stats = gameState.stats[gameState.currentGame];
                stats.wins = (stats.wins || 0) + 1;
                
                if (gameState.timer < (stats.bestTime || Infinity)) {
                    stats.bestTime = gameState.timer;
                }
                
                if (gameState.moves < (stats.bestMoves || Infinity)) {
                    stats.bestMoves = gameState.moves;
                }
                
                if (gameState.score > (stats.highScore || 0)) {
                    stats.highScore = gameState.score;
                }
                
                localStorage.setItem('puzzleStats', JSON.stringify(gameState.stats));
            }
            
            // Show celebration
            createConfetti();
            
            // Update overlay
            elements.overlayTitle.textContent = 'ðŸŽ‰ Puzzle Complete!';
            elements.overlayMessage.innerHTML = `
                Great job! You completed the ${gameState.currentGame} puzzle!<br><br>
                Time: ${formatTime(gameState.timer)}<br>
                Moves: ${gameState.moves}<br>
                Score: ${gameState.score}<br><br>
                <small>Want to play again?</small>
            `;
            elements.gameOverlay.style.display = 'flex';
        }

        function quitToMenu() {
            gameState.gameActive = false;
            clearInterval(gameState.timerInterval);
            
            elements.gameContainer.style.display = 'none';
            elements.mainMenu.style.display = 'block';
            elements.mainHeader.style.display = 'block';
            elements.backToGames.style.display = 'none';
            elements.gameOverlay.style.display = 'none';
            elements.statsOverlay.style.display = 'none';
        }

        function showStats() {
            let statsHTML = '<div style="max-height: 300px; overflow-y: auto;">';
            
            for (const [game, data] of Object.entries(gameState.stats)) {
                if (data.wins > 0) {
                    statsHTML += `
                        <div style="background: var(--bg); padding: 15px; border-radius: 10px; margin-bottom: 10px;">
                            <h4 style="color: var(--primary); margin-bottom: 10px;">
                                <i class="fas fa-gamepad"></i> ${game.charAt(0).toUpperCase() + game.slice(1)}
                            </h4>
                            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px;">
                                <div>Wins: <strong>${data.wins}</strong></div>
                                ${data.bestTime ? `<div>Best Time: <strong>${formatTime(data.bestTime)}</strong></div>` : ''}
                                ${data.bestMoves ? `<div>Best Moves: <strong>${data.bestMoves}</strong></div>` : ''}
                                ${data.highScore ? `<div>High Score: <strong>${data.highScore}</strong></div>` : ''}
                            </div>
                        </div>
                    `;
                }
            }
            
            if (statsHTML === '<div style="max-height: 300px; overflow-y: auto;">') {
                statsHTML += '<p style="text-align: center; color: var(--text-secondary);">No statistics yet. Play some games!</p>';
            }
            
            statsHTML += '</div>';
            elements.statsContent.innerHTML = statsHTML;
            elements.statsOverlay.style.display = 'flex';
        }

        // ==================== EVENT LISTENERS ====================
        function setupMainEventListeners() {
            // Menu cards
            document.querySelectorAll('.menu-card').forEach(card => {
                card.addEventListener('click', function() {
                    const game = this.dataset.game;
                    startGame(game);
                });
            });

            // Theme toggle
            elements.themeToggle.addEventListener('click', toggleTheme);
            
            // Back to games button
            elements.backToGames.addEventListener('click', quitToMenu);
            
            // Main menu buttons
            document.getElementById('howToPlay')?.addEventListener('click', () => {
                alert(`ðŸŽ® ULTIMATE PUZZLE COLLECTION ðŸŽ®\n\nHOW TO PLAY:\n\n1. Select a game from the menu\n2. Choose difficulty (Easy, Normal, Hard)\n3. Read the instructions for each game\n4. Play using mouse/touch controls\n5. Complete puzzles to earn high scores!\n\nðŸ“± MOBILE CONTROLS:\nâ€¢ Tap to select/interact\nâ€¢ Touch and drag for word search\nâ€¢ Long press for alternative actions\n\nâ­ FEATURES:\nâ€¢ 6 fully playable puzzle games\nâ€¢ 6 more games coming soon\nâ€¢ Difficulty levels\nâ€¢ Game statistics\nâ€¢ Dark/Light themes\nâ€¢ Mobile-friendly design`);
            });
            
            document.getElementById('viewStats')?.addEventListener('click', showStats);
            
            // Stats overlay buttons
            document.getElementById('clearStats')?.addEventListener('click', () => {
                if (confirm('Clear all game statistics?')) {
                    gameState.stats = {
                        memory: { wins: 0, bestTime: 0, bestMoves: 0 },
                        sliding: { wins: 0, bestTime: 0, bestMoves: 0 },
                        sudoku: { wins: 0, bestTime: 0 },
                        wordsearch: { wins: 0, bestTime: 0 },
                        nonogram: { wins: 0, bestTime: 0 },
                        match3: { wins: 0, highScore: 0 }
                    };
                    localStorage.setItem('puzzleStats', JSON.stringify(gameState.stats));
                    showStats();
                    showToast('Statistics cleared!', 'success');
                }
            });
            
            document.getElementById('closeStats')?.addEventListener('click', () => {
                elements.statsOverlay.style.display = 'none';
            });
        }

        function toggleTheme() {
            gameState.theme = gameState.theme === 'dark' ? 'light' : 'dark';
            document.body.className = `${gameState.theme}-theme`;
            elements.themeToggle.innerHTML = gameState.theme === 'dark' ? 
                '<i class="fas fa-moon"></i> Dark Mode' : 
                '<i class="fas fa-sun"></i> Light Mode';
            localStorage.setItem('puzzleTheme', gameState.theme);
        }

        // ==================== INITIALIZATION ====================
        function init() {
            // Load saved theme
            const savedTheme = localStorage.getItem('puzzleTheme');
            if (savedTheme) {
                gameState.theme = savedTheme;
                document.body.className = `${gameState.theme}-theme`;
                elements.themeToggle.innerHTML = gameState.theme === 'dark' ? 
                    '<i class="fas fa-moon"></i> Dark Mode' : 
                    '<i class="fas fa-sun"></i> Light Mode';
            }
            
            // Load saved stats
            const savedStats = localStorage.getItem('puzzleStats');
            if (savedStats) {
                gameState.stats = JSON.parse(savedStats);
            }
            
            setupMainEventListeners();
            
            // Hide back button initially
            elements.backToGames.style.display = 'none';
            
            // Check for mobile device
            if ('ontouchstart' in window || navigator.maxTouchPoints) {
                document.body.classList.add('touch-device');
            }
            
            console.log('Ultimate Puzzle Collection loaded successfully!');
        }

        // Initialize when page loads
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
